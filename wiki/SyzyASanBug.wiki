#summary I've been assigned a SyzyASAN bug, what do I do?

= I've been assigned a SyzyASAN bug, what do I do? =

== 1. Get an existing minidump if you can. ==

You will more than likely have a minidump from [http://go/crash] (Google internal only), or if the bug originated from !ClusterFuzz. 
If you haven't already, set up your symbol path and source paths. This will allow your debugger to automagically retrieve appropriate symbols and source code as you peruse the crash dump.

You can do this by running something like this in a command line shell - you only need to do this once per machine/user account.
{{{
mkdir %TEMP%\srcsrv
setx _NT_SOURCE_PATH "SRV*%TEMP%\srcsrv"
set _NT_SOURCE_PATH=SRV*%TEMP%\srcsrv

mkdir %TEMP%\symbols\google
mkdir %TEMP%\symbols\microsoft

setx _NT_SYMBOL_PATH "SRV*%TEMP%\symbols\google*http://chromium-browser-symsrv.commondatastorage.googleapis.com;SRV*%TEMP%\symbols\microsoft*http://msdl.microsoft.com/download/symbols"

set _NT_SYMBOL_PATH=SRV*%TEMP%\symbols\google*http://chromium-browser-symsrv.commondatastorage.googleapis.com;SRV*%TEMP%\symbols\microsoft*http://msdl.microsoft.com/download/symbols
}}}

We like to use Windbg  

Otherwise, you'll have to try to use the information in the bug to reproduce it.

== 2. Explore the minidump or a running process. ==

If you're using a minidump you can open it directly in !WinDbg and you'll immediately be placed into the frame where the exception was raised. You can get detailed information about the crash, and hopefully this will be useful in finding a repro or providing insight into a fix.

{{{
# Print the stack trace associated with the crash. This should start in 
# system libraries, and go through asan_rtl.dll.
> kn

# Find the "asan_rtl!agent::asan::ReportBadMemoryAccess" frame in the 
# previous stack trace and make it the current frame.
> .frame %FRAME_NUMBER_IN_HEX%

# Dump the error info associated with the crash.
> dt bad_access_info

# Dump the stack trace associated with the allocation.
> dps @@(bad_access_info.alloc_stack) L@@(bad_access_info.alloc_stack_size)

# Dump the stack trace associated with the free.
> dps @@(bad_access_info.free_stack) L@@(bad_access_info.free_stack_size)

# Switch contexts to the exception record in the minidump.
> .ecxr

# Dump the stack trace associated with the ASAN error.
> kv
}}}

The minidump will automatically grab some regions of memory so you may have access to the actual object that was used-after-free, or other data structures. SyzyASAN will preserve the contents of the object so you may be able to glean information from it.

Note that SyzyASAN prefixes each allocated block with a header, which contains the state of the block as well as serving like a red-zone to catch underruns. You can inspect the state of the header by a command such as:
{{{
# Inspect the block header for the object at 0x04189bd8.
>dt asan_rtl!agent::asan::HeapProxy::BlockHeader 0x04189bd8-10
   +0x000 magic_number     : 0y110010101000000011100111 (0xca80e7)
   +0x000 state            : 0y00000000 ( 0, ALLOCATED )
   +0x004 block_size       : 0x14
   +0x008 alloc_stack      : 0x00d9f260 agent::asan::StackCapture
   +0x00c alloc_tid        : 0x1bb8
}}}

You can also dump the contents of memory snippets containing heap data, and use the SyzyASAN magic value (0xca80e7, or dword-aligned XXe780ca in hex dumps) to locate the block headers.
SyzyASAN will sometime report invalid access where the underlying cause is heap corruption. If you suspect this is the cause of your error report, then looking for nearby block headers and correlating their locations and lengths will often allow you to determine whether that's the fact.

== 3. Make sure you try to reproduce with a SyzyASAN build. ==

First of all, your life will be much easier if you reproduce the bug with a SyzyASAN instrumented version of Chrome. You can tell if your version of Chrome is instrumented with SyzyASAN if `dumpbin /imports` shows a dependency on `asan_rtl.dll`. Also, the version number will be w.x.y.z, where z > 0.

In recent SyzyASAN builds you'll also see SyzyASAN mentioned in the version string in e.g. chrome://version, as so:
{{{
Google Chrome	29.0.1507.2 (Official Build 199891) canary SyzyASan
}}}

=== 4. Instrumenting your own build. ===

If you are unable to get ahold of the latest SyzyASAN instrumented canary you can always instrument Chromium yourself. The latest Syzygy binaries are included in `third_party\syzygy\binaries\exe`. Once you've built `chrome.dll` you can instrument it using:

{{{
instrument.exe --mode=asan --input-image=path\to\chrome.dll --output-image=path\to\another\chrome.dll --debug-friendly
}}}

Replace your original `chrome.dll` with the instrumented one, and make sure that `asan_rtl.dll` is alongside it.

*NOTE:* You can't instrument Debug builds right now due to incremental linking being enabled. Easiest is to use a Release build, but if you want a Debug build you have to disable incremental linking and enable profile information (`/PROFILE`). This is not directly supported right now, but you can get this behaviour through judicious GYP file tweaking.

*NOTE:* SyzyASan doesn't support the Large Address Aware builds, you can use [http://msdn.microsoft.com/en-us/library/vstudio/d25ddyfc.aspx editbin] to turn off this flag on chrome.exe.

== 5. Find a reproduction. ==

If the bug has been found by !ClusterFuzz you're in luck, as there will be a nice self-contained way to reproduce it.

Otherwise it's up to you to find a way to reproduce the bug. The bug report should include information to help you do this, but there's no magic recipe here. You'll know you've got a reproduction when you see `asan_rtl` in the stack of the exception, and you see alloc/free stack traces that match the bug.

== 5. Fix it! ==

This is up to you! If we could automate this, we would!